@0x8e2af0a9b5c7d1e3;  # Unique file ID

# Trading Domain Schema for 0-hummingbot
#
# This schema defines the core types for trading operations.
# All values that involve prices/quantities use Tensor for
# probabilistic confidence tracking.

using Cxx = import "/capnp/c++.capnp";
$Cxx.namespace("zero::trading");

# ============================================================================
# Core Tensor Type (imported concept from 0-lang)
# ============================================================================

struct Tensor {
    # Shape of the tensor (e.g., [1] for scalar, [768] for embedding)
    shape @0 :List(UInt32);
    
    # Flattened tensor data
    data @1 :List(Float32);
    
    # Confidence score [0.0, 1.0]
    confidence @2 :Float32;
}

# ============================================================================
# Enumerations
# ============================================================================

enum OrderSide {
    buy @0;
    sell @1;
}

enum OrderType {
    market @0;
    limit @1;
    stopLoss @2;
    stopLossLimit @3;
    takeProfit @4;
    takeProfitLimit @5;
}

enum OrderStatus {
    pending @0;
    open @1;
    partiallyFilled @2;
    filled @3;
    cancelled @4;
    rejected @5;
    expired @6;
}

enum PositionSide {
    long @0;
    short @1;
}

enum TimeInForce {
    gtc @0;   # Good Till Cancelled
    ioc @1;   # Immediate Or Cancel
    fok @2;   # Fill Or Kill
    gtd @3;   # Good Till Date
}

# ============================================================================
# Proof Types
# ============================================================================

struct Proof {
    # Type of proof
    union {
        halting @0 :HaltingProof;
        shape @1 :ShapeProof;
        signature @2 :SignatureProof;
        strategy @3 :StrategyProof;
    }
}

struct HaltingProof {
    maxSteps @0 :UInt64;
    fuelBudget @1 :UInt64;
}

struct ShapeProof {
    inputShapes @0 :List(List(UInt32));
    outputShape @1 :List(UInt32);
}

struct SignatureProof {
    agentId @0 :Data;      # Public key
    signature @1 :Data;    # Cryptographic signature
    timestamp @2 :UInt64;  # Unix timestamp
}

struct StrategyProof {
    # Proof that an order was generated by a specific strategy
    strategyHash @0 :Data;       # Hash of the strategy graph
    inputHash @1 :Data;          # Hash of market data inputs
    executionTrace @2 :Data;     # Serialized execution trace
    agentSignature @3 :Data;     # Agent's signature
}

# ============================================================================
# Order Types
# ============================================================================

struct Order {
    # Content-addressed order ID (sha256 of order content)
    id @0 :Data;
    
    # Trading pair symbol (e.g., "BTC/USDT")
    symbol @1 :Text;
    
    # Order side
    side @2 :OrderSide;
    
    # Order type
    type @3 :OrderType;
    
    # Quantity as tensor (allows confidence tracking)
    quantity @4 :Tensor;
    
    # Price as tensor (for limit orders)
    price @5 :Tensor;
    
    # Time in force
    timeInForce @6 :TimeInForce;
    
    # Strategy confidence in this order [0.0, 1.0]
    confidence @7 :Float32;
    
    # Proof of strategy intent
    proof @8 :StrategyProof;
    
    # Client order ID (optional, for tracking)
    clientOrderId @9 :Text;
    
    # Creation timestamp
    createdAt @10 :UInt64;
}

struct OrderResponse {
    # Exchange-assigned order ID
    exchangeOrderId @0 :Text;
    
    # Our order ID
    orderId @1 :Data;
    
    # Current status
    status @2 :OrderStatus;
    
    # Filled quantity
    filledQuantity @3 :Tensor;
    
    # Average fill price
    avgFillPrice @4 :Tensor;
    
    # Timestamp
    timestamp @5 :UInt64;
    
    # Error message (if rejected)
    errorMessage @6 :Text;
}

# ============================================================================
# Trade Types
# ============================================================================

struct Trade {
    # Trade ID
    id @0 :Data;
    
    # Associated order ID
    orderId @1 :Data;
    
    # Symbol
    symbol @2 :Text;
    
    # Side
    side @3 :OrderSide;
    
    # Executed quantity
    quantity @4 :Tensor;
    
    # Execution price
    price @5 :Tensor;
    
    # Fee paid
    fee @6 :Tensor;
    
    # Fee currency
    feeCurrency @7 :Text;
    
    # Execution timestamp
    timestamp @8 :UInt64;
    
    # Whether this was a maker trade
    isMaker @9 :Bool;
}

# ============================================================================
# Position Types
# ============================================================================

struct Position {
    # Symbol
    symbol @0 :Text;
    
    # Position side
    side @1 :PositionSide;
    
    # Current quantity
    quantity @2 :Tensor;
    
    # Entry price (average)
    entryPrice @3 :Tensor;
    
    # Mark price (current)
    markPrice @4 :Tensor;
    
    # Unrealized PnL
    unrealizedPnl @5 :Tensor;
    
    # Realized PnL
    realizedPnl @6 :Tensor;
    
    # Leverage (for futures)
    leverage @7 :Float32;
    
    # Liquidation price
    liquidationPrice @8 :Tensor;
    
    # Last update timestamp
    updatedAt @9 :UInt64;
}

# ============================================================================
# Market Data Types
# ============================================================================

struct Ticker {
    symbol @0 :Text;
    bidPrice @1 :Tensor;
    bidQuantity @2 :Tensor;
    askPrice @3 :Tensor;
    askQuantity @4 :Tensor;
    lastPrice @5 :Tensor;
    volume24h @6 :Tensor;
    high24h @7 :Tensor;
    low24h @8 :Tensor;
    timestamp @9 :UInt64;
}

struct OrderBookLevel {
    price @0 :Tensor;
    quantity @1 :Tensor;
}

struct OrderBook {
    symbol @0 :Text;
    bids @1 :List(OrderBookLevel);
    asks @2 :List(OrderBookLevel);
    timestamp @3 :UInt64;
    sequenceNumber @4 :UInt64;
}

struct Candle {
    symbol @0 :Text;
    interval @1 :Text;      # e.g., "1m", "5m", "1h"
    openTime @2 :UInt64;
    closeTime @3 :UInt64;
    open @4 :Tensor;
    high @5 :Tensor;
    low @6 :Tensor;
    close @7 :Tensor;
    volume @8 :Tensor;
    trades @9 :UInt32;
}

# ============================================================================
# Strategy Types
# ============================================================================

struct StrategyConfig {
    # Strategy name
    name @0 :Text;
    
    # Strategy graph hash
    graphHash @1 :Data;
    
    # Trading pair
    symbol @2 :Text;
    
    # Connector to use
    connector @3 :Text;
    
    # Parameters as key-value pairs
    parameters @4 :List(Parameter);
    
    # Minimum confidence threshold to execute
    minConfidence @5 :Float32;
    
    # Maximum position size
    maxPositionSize @6 :Tensor;
    
    # Execution interval in milliseconds
    intervalMs @7 :UInt64;
}

struct Parameter {
    key @0 :Text;
    value @1 :Tensor;
}

struct StrategyState {
    # Current position
    position @0 :Position;
    
    # Open orders
    openOrders @1 :List(Order);
    
    # Recent trades
    recentTrades @2 :List(Trade);
    
    # Internal state tensor
    internalState @3 :Tensor;
    
    # Last execution timestamp
    lastExecution @4 :UInt64;
}

# ============================================================================
# Connector Types
# ============================================================================

struct ConnectorConfig {
    # Connector name
    name @0 :Text;
    
    # Exchange type (cex/dex)
    exchangeType @1 :Text;
    
    # Base URL (for CEX)
    baseUrl @2 :Text;
    
    # WebSocket URL
    wsUrl @3 :Text;
    
    # Chain ID (for DEX)
    chainId @4 :UInt32;
    
    # Contract address (for DEX)
    contractAddress @5 :Text;
    
    # Rate limits
    rateLimits @6 :RateLimits;
}

struct RateLimits {
    requestsPerSecond @0 :UInt32;
    ordersPerSecond @1 :UInt32;
    requestsPerMinute @2 :UInt32;
}

# ============================================================================
# Event Types (for logging and monitoring)
# ============================================================================

struct TradingEvent {
    timestamp @0 :UInt64;
    
    union {
        orderPlaced @1 :Order;
        orderFilled @2 :Trade;
        orderCancelled @3 :OrderResponse;
        positionOpened @4 :Position;
        positionClosed @5 :Position;
        error @6 :ErrorEvent;
    }
}

struct ErrorEvent {
    code @0 :Text;
    message @1 :Text;
    context @2 :Text;
}
